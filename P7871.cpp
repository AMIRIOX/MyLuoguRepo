// 题意：规定一个数字会向两侧较小的那个数字传递能量，给定s，t要求s激活能传到t
// 首先分析传递的本质，可以发现每次传递的条件仅取决于Wi两侧的Wi-1 Wi+1大小而与Wi
// 本身无关，再考虑整体多次传递：s要传到t，必然持续单向传递
// 也就是说a不断向右，a+1<a-1, a+2<a, a+3>a+1 ... b<b-2
//（即给定一些编号对应数字的关系，构造一个符合要求的字典序最小的编号序列）
// 思想1：用有向图刻画大小关系，如果要求Wi+1<Wi-1（即能量向右传递）就i+1->i-1连边；
// 反向如果要求Wi+1>Wi-1（即能量向左传递）就i-1->i+1连边；；如果发生双向边矛盾则无解；
// 那么问题就转变到了为一个有向图上的每个点分配一个值x使得
// 1. x在该点编号位置上排列时字典序最小.
// 2. x大于该点所有出边到达的点上的值x'.(根据连边的定义：若Wi->Wi+2连边意味着Wi>Wi-2)
// 做法考虑贪心：从左往右(满足字典序,我们要让小的编号分配到较小的值x)用计数器cntx赋值
// 并且让高层上的点(出点)的x值尽可能大（具体则为一直到这同向链末尾的长度作为x值）。这样做：
// 1. 因为是从左往右考虑，即使2->4->6<-8<-10这样的情况，我们也会先考虑让2的x值尽可能小
// 2. 在满足1.的条件下，使得满足“x大于该点所有出边到达的点上的值x'”的条件下x最小（同向链的长度）
// 思想2：用两个数组存链状的有向图，Ai=true表示边i->i+2；Bi=true表示i+2->i有一条边
// 这样就变成了区间赋值问题。如果直接存图，dfs编号复杂度爆炸并且麻烦。
// 由于没有区间清0，所以考虑差分，然后前缀和统计即可
// 论外：也可反向建图然后拓扑排序，dfs找环看有没有矛盾。
#include <iostream>
#include <cstdio>
using namespace std;
const int maxn=3e5+10;
int n,q;
int A[maxn],B[maxn],ans[maxn];
signed main() {
	scanf("%d %d", &n, &q);
	while(q--) {
		int si, ti;
		scanf("%d %d", &si, &ti);
		if(si<ti) {
			// s<t向右去，s-1>s+1, s>s+2 ... t-2>t
			// 即s-1->s+1一直到t-2->t都要连边，所以A[s-1]...A[t-2]都要赋值
			// for(int i=s-1; i<=t-2; i++) A[i]=true;
			A[si-1]++; A[ti-2+1]--; // 差分
			// cout << "filling " << si-1 << " " << ti-2+1 << endl;
		}else if(si>ti) {
			// s>t向左去，s-1<s+1, s-2<s, s-3<s-1 ... t<t+2
			// 即s+1->s-1一直到t+2->t都要连边，所以B[t]...B[s-1]都要赋值
			B[ti]++; B[si-1+1]--;
			// cout << "filling " << ti << " " << si-1+1 << endl;
		}
	}
	for(int i=1;i<=n;i++) {
		A[i]+=A[i-1];
		B[i]+=B[i-1];
		if(A[i] && B[i]) {
			printf("QED\n");
			return 0;
		}
		// 前缀和 求出原A B数组 若无解则输出
	}

	int cntx=0;
	for(int i=1;i<=n;i++) {
		if(!ans[i]) {
			int c=1; for(int j=i; A[j] && j+2<=n; j+=2) c++;
			for(int v=1; v<=c; v++) ans[i+2*c-2*v]=++cntx;
		}
	}
	for(int i=1;i<=n;i++) {
		printf("%d ", ans[i]);
	}
	puts("");
	return 0;
}