* 思考方式
    1. 答案由什么构成?(求解或计数问题适用, 检验不适用)
        即观察题目性质。需要注意的是想到了一种答案构成/计算方法后不要局限，    
        考虑换个思路
    2. 构成的量多了试着"固定"某一个量(暴力或者二分 或者依据题意直接贪心计算出来)
    3. “计算答案包含的区间个数”更常见的做法是“计算每个区间对答案的贡献”    
        正难则反的另一种应用 (`CF 974 Div3 D`)
    4. 不要复杂度焦虑，多考虑几种暴力/模拟做法，再考虑正解(`P1904`)
    5. 当题目答案构成一眼看不出来时可以观察规律 究定义等（`P1904`）
    6. 遇到求解问题时通过两方面思考
        * 一方面是答案如何构成?对于需要多次操作的问题, 最终答案会是什么样的?
            这一点需要细节,而不是大概的描述.例如对 `CF 991 Div3 D`, 
            不能只想"答案是包含相邻逆序对的递减序列", 还要想如何从初始状态构造出那样的答案.
        * 另一方面是在线动态做法, 除了总体策略上的离线贪心, 你应该更加去熟悉一下在线贪心
            即每次操作采取的特定决策. 通常第 i 次操作完成时, 前 i / 后 i 个都已经构造成了答案性质
            另外一次决策如果是"对某一对象采取某一操作"的形式, 不要拘泥于"对不同对象多次采取这次操作",
            也考虑一下这次操作对同一对象能不能延续操作
    6. 遇到检验问题时积极转化问题(二分的 check 就是一种转化问题)
        * 直接用数学语言列式描述需要 check 的要求    
        (`ABC 373 E` 就是把 "候选人 i 在加 mid 票时能稳定胜选" 转化为 "前 m 个候选人加到 b[i] + mid + 1 票的代价小于 k"
    7. 能枚举一个量就相当于可以少考虑一个条件, 因此看数据范围哪个能枚举也是比较重要的,
        正解很可能就是有一个量枚举然后剩下的量运用其他算法
    8. 有式子不一定是数学题, 尝试变个形, 对推式子积极一点, 而且别推一半想到了就做 (`CF 993 Div4 F`)
        继续往下推往往有更好的做法
    9. 哈希很有用. 不过 `std::map` 是红黑树, `std::unordered_map` 才是哈希表
    10. 遇到需要排序同时知道排序后的元素在原数组位置的(如保持按照原顺序输出), 
        可以开个下标数组 ord 建立排序后的数组与原顺序数组的联系.
        ```cpp
        vector<int> ord(n);
        iota(ord.begin(), ord.end(), 0);
        sort(ord.begin(), ord.end(), [&](int i, int j) { return a[i] < a[j]; });
        // 此时 ord[i] 是排序后数组的下标对原数组下标的映射, 原数组的第 ord[i] 位就是新数组的第 i 位
        // 操作有序数组: 随 i 递增, 有序数组递增
        check(b[i], foo()); // or a[ord[i]]
        // 操作原数组:   ord[i] 获取这个数在原数组的位置
        ans[ord[i]] = l;
        ```
    11. 遇到多次查询, 查询有多种情况(比如不同的属性 k 情况下进行查询), 
        而查询本身又包含状态 x, 如果枚举 x, k, 离线把所有 (i, x, k) 查询回答了是不可能的,
        可以考虑更换枚举顺序, 然后考虑涉及单调性 (`CFE 168 E`), 例如对于 `CFE 168 E`):
        枚举等级再枚举步长, 发现:
        * 到达同一等级时步长为 k 的位置一定比 k+1 更靠前(或相同) 所以不会冲突; 
        * 同时对于不同等级, 在 lvl-1 计算完之后可以删除 <= lvl-1 的怪物,
            这样保证在任意 lvl 等级, 留下的怪物一定都比 lvl 等级高,
            这样在枚举步长 k 的循环里就可以放心直接向前推进 k-1 位而不用检查等级

* 性质/典/trick
    1. 同步加值不影响相对大小
    1. 如果每次操作都是+1 -1, 那么值的变化一定是连续的，[min, max] 之间的每个值都会出现
        对一个只存在-1 +1的数组，一个子数组的和是presum[r] - presum[l - 1], 枚举每个r，  
        减去的`presum[l - 1]`最小值就是和的最大值，减去最大值就是和的最小值
    1. 对 i 找 j 有出现 j 会再找到 i 导致计数重复时，可以直接除以 2 考虑。但也要考虑 i 找 i, i 再找回 i 的自身重复情况。
    1. 区间计数一种常见的 trick: 计数[l, r] 的某个值，可以计数[0, r]上的值，再减去[0, l - 1] 上的值（`CF 995 Div3 D)
        推广到一般情况，计数一段区间内同时具有两种性质的数的个数，如果注意到性质不重复，可以计数一种减去另一种
    1. 灵活考虑枚举什么量，二分什么量，同时积极大胆地想一想两种看似结合的量能不能分开考虑
    1. (\* 典) 最终要求总 max 的话不要被过程的区间 max 迷惑，考虑一下修改会不会影响总 max 的值, 
        影响的话看一看能不能通过确定手段计算回来(这一条其实类似`1.`）
    1. 线性结构上, 对相邻元素的相同可互补操作(例如反转相邻两位的符号) 有传递性 (`CF 849 Div4 E `)
    1. 前缀和判断一个区间是否连续上升
    1. 区间加可以差分打懒标记(实质是将多个连续写操作合并) 然后在访问之前(读操作) push 到原数组同步
    1. 利用前缀和可以 O(1) 计算将某区间内所有数变为 x 所需的差值.
    1. 位运算 `and/or` 操作只影响某一位, 可以分解整数的每个 bit 分别考虑
    1. 具有覆盖性质的操作只需要做一遍, 因为之前的相同操作被覆盖了.
        利用这一点可能找出新的思路, 如顺序相关 )`CFE 173 E`
    1. 寻找操作顺序相关, 以操作为节点, 操作顺序约束为边建图, 跑 dfs/三色bfs/拓扑排序 等 (`CFE 173 E`)
    1. [l, r] 如果连续那就是个区间问题, 这个连续性质很重要 (`CFE 172 D`)
    2. 找两个无公共部分的连续等长区间和的最大值可以枚举左区间计算最大值 `maxl`,
        同步更新 `maxl` + 右区间和的最大值
        ```cpp
        int maxk = -0x3f3f3f3f, ans = -0x3f3f3f3f;
        for(int i = k; i + k <= n; i++) {
            // [i - k + 1, i]   [i + 1, i + k]
            maxk = max(maxk, sum{i - k + 1, i});
            ans = max(ans, maxk + sum{i + 1, i + k});
        }
        ```
    3. 枚举两个无公共部分子区间可以枚举 `i` (前半段结尾后半段开始), 
        再分别枚举端点
        ```cpp
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= i; j++) cnt[a[i] ^ a[j - 1]]++;
            for(int j = i + 1; j <= n; j++) ans += cnt[a[j] ^ a[i + 1 - 1]];
        }
        ```
    4. 数字和字母挨在一块最好用 cin 读, 别先读入然后离线处理.
    5. 使用二进制表达集合的时候，标准化地
        若为 1-based 索引, 则使用 `(1 >> (i - 1)) & 1` 表示第 `i` 个元素在集合中
        若为 0-based 索引, 则使用 `(1 >> i) & 1`
    6. 位运算的一些性质，如 `x | 1` 一定为 1，`x & 0` 一定为 0
    7. `C(n, k) = C(n, n - k)`，`ABC 386 E` 放宽上界 `O(k * C(n, k))`, 只搜 `k`, `n-k` 中小的那些即可
    8. 同`ABC 386 E`，搜长度更短的那一部分如何计算另一部分? 先全都异或一遍，然后利用异或两次相当于没异或撤销掉长度短的那部分。

* 模拟
    1. 两个对象随时间变化的问题, 如果涉及情况比较复杂可以试图分情况考虑而不是强行归为一类 (`ABC-391 D`)

* 贪心
    1. 贪心常和前缀和/后缀和联动
    2. 一定要看懂题，知道求的式子是什么。   
        贪心的核心是决策，不一定是推式子，搞清楚哪个是决策
    3. 然后可以考虑加入其他算法优化

* 差分
    1. `b[i] = a[i] - a[i - 1]`    
    在进行区间增减，求出某一个位置修改后的值时      
    `b[i]` 作为差分数组进行标记， `a[i]` 为 `b[i]` 的前缀和，代表位置 i 的值
    2. 具有区间加减法、求某一位修改后值特性的题目都要想着一点将题目转换为能够进行差分的形式。
    3. 可以从 0 计算 `b[i]` 达到只记录变化量, 而后在前缀和中具体计算值
    4. 将问题转化为区间增减、求单点值后， 可以通过从差分进行区间操作, 然后前缀和反构造出具体的单点值

* 前缀和
    1. 前缀和一定要考虑 `1~r`的情况,在考虑将 `l~r` 转换过去.
    2. 列式子拆括号化简可得出前缀和,因此要对式子中隐含的前缀和有概念
    3. 异或操作也可以前缀和
    4. 一定要注意前缀和化之后的数组不能再直接使用 a[p] 而是应当 `a[p] - a[p - 1]`
    5. 有连续区间, 答案/费用和区间和有关的都自然想一下前缀和
    6. 有的题是对前缀和数组再前缀和, 最好封装一下 (`EDU 171 D`, 三层前缀和)
    6. 多重前缀和容易被下标绕晕, 请列式子区分, 每次把上一级的前缀和数组当成普通数组即可(不要打破 abstract barrier)
    7. 1-based 下标 sum[l, r] = p[r] - p[l - 1]; 计算用 i = [1, n], p[i] = p[i - 1] + a[i];
       0-based 下标 sum[l, r] = p[r + 1] - p[l]; 计算用 i = [1, n], p[i] = p[i - 1] + a[i - 1];
    8. 计算将某一区间内所有数字变成 x 的代价可以用 x * len[l, r] - sum[l, r] 计算

* 双指针
    1. 滑动窗口是一种特殊的双指针。(`CFE 170 C`)
    2. 涉及到所求对象连续的就用一下双指针 
    3. 涉及到数组中两个数相匹配/对应关系，且有一定顺序约束(`ABC 388 E`, 很好的双指针)

* 搜索
    1. 你只管搜索枚举, 剩下的交给 min/max 
    2. 注意搜索方向, 可能会有不能转弯的情况
    3. 千万注意数据范围能否搜索!!! (不仅要在意"否"也要在意"能")
    4. 搜索的复杂度是 解答树节点数 * 拓展节点的代价    
        但要注意解答树节点数不一定全部会拓展，更准确的计算方法是 枚举情况数 * 拓展节点代价
    5. 也有的 dfs 分析复杂度可放宽上界(`ABC 386 E`，O(k * C(n, k))，k 是解答树高度，C(n, k) 是叶子节点个数)，
    5. 搜索的顺序十分值得注意，有时结合题目性质能剪枝一大部分(`P7073`)
    6. bfs 求01最短路的拓展：bfs求最小转弯次数（`P1649`）   
        此时为了保证三角不等式，必须每次拓展全部可以拓展的节点入队，然后再继续下一次迭代   
        对于本题也就是一直走到必须转弯的（障碍或边界）再停下（既转弯一次了），否则一直入队拓展节点

* 二分
    1. 常见的二分答案式的单调性是 对区间 $ [L,R] $ 上的函数 $ F(x) $, 存在 $ x_0 $ 使得...（略）
    2. 一种二分查找式的单调性：`ABC-380 E`，对于每个`/`来讲，左面的1少于右面的2则说明`/`偏左，否则偏右
    3. 大部分复杂度是 $ O(n\log n) $ 的，其中二分 $\log n$, check 可以是 n 的，不用担心。
    4. 如果题目是求一个区间/区间长度, 可以分别看看左右端点 l r 有没有单调性. 可以看看 `CF 993 Div4 E`
    5. `upper_bound(.., vmax) - lowerbound(.., vmin)` 求 `..` 中值在 `[vmin, vmax]` 之间的个数。
        当然， `..` 要有序。
    6. 要有大局意识，对 i 找 j 有重复，发现 j 找 i 也会找一边，所以不去重，最后除以 2 即可 `(CF 995 Div3)`
        但要注意除了 i 找 j == j 找 i 这种二倍重复之外，还有可能出现 i 找到 i, i 再找到 i 的情况
    7. 把问题转化为子区间的父区间与其差值, 排序使得检查 i 时 i 的父区间已经被检查到并加入有序集合
        二分有序集合(也就是其可能父区间的集合)右端点可以找到右端点最近的覆盖 i 的父区间
    8. 继上条, 沿原点反转所有区间即可再找到左端点最近的, 从而统计出覆盖某一区间的最小区间
        (`CFE 172 D`, 这个也要用到 ord 排序)

* 递归
    1. 注意递归的终止条件, 部分递归虽然形式是一样的但终止条件略有不同, 如 `P1010`    
        这里不知道怎么说了, 感觉不如初高中脑子好使了
    2. 搜索能草掉很多递归范式. 别局限思路.
        将 n 拆分为 1, 2, 3, 4, .. , m 中几个数的和:
            (1) 深度优先搜索, 不降原则防止重复
            (2) 递归为两个情况: 将 n-m 分为不超过 m 的数的和, 将 n 分为不超过 m-1 的数的和
                推广到其他部分, m-1 也可以是 next(m) 等 (`recursion4.cpp`)

* 动态规划
    0. 要求计数(方案种数等)而不要求具体方案构成的一般 dp (`CFE 170 E`)
    1. 注意 dp 数组一般为 i64, 以及 dp 数组开的是否够大(尤其对于字符串上 dp, 要注意 ASCII)
    2. 注意转移顺序, 以及是否越界
    3. 经典选或不选的模型, 因为两种决策中间的过程不一样, 所以要取 max
    4. 一般你觉得没有最优子结构性质的时候就考虑把你想的 dp 状态加一维
        巧妙一点的就是所谓接近答案要求但不完全是答案的中间状态     
        难绷一点就是状态压缩 dp 这种
    5. 动态规划处理的尺度是决策。只要决策不冲突或者能避免冲突，可以同时处理两条路径的决策( `P1004` 方格取数)
    6. 有时候 dp 初始化也需要注意，不能影响后续计算 dp 数组的值
    7. 我懒得写了也说不出来什么了, 我就纳闷怎么有人特么式子都写对了然后计算边界和初始值写不对的, 自己看 `CF 991 Div3 E`吧.
        算了还是写一下吧.
        * 遇到字符串 dp, 下标不统一的话按 dp 状态的实际意义来, 再在str[i - 1]中映射
        * min 决策的 dp 每个状态初始值都填一下 inf (或者结合实际问题下的最大答案)
        * (存疑) 一般很多 dp 初始化直接 `dp[0][0] = ` 就行了? 再多些题具体分析吧.
        * 状态转移不仅要考虑决策(即 min 实现的部分), 也要考虑从每次决策是怎么**从之前的状态**转移过来的
            (即 min(A, B) 中 A, B 的计算往往和先前的 dp 状态有关系)
        * 关于计算边界问题: 遇到二维状态中有一维需要依赖-1的, 也可以用+1往后算代替
            如果遇到两个维度的边界不同就都枚举到最大边界, 然后加个判断约束一下
    8. 经典选择(决策)问题真的别忘了动态规划, 尤其是猜的贪心是错的的时候
        线性结构 dp 一般是要存一下某个根据决策改变的值, 然后由去掉这个决策影响的之前的状态转移过来    
        当然这样一般就是 O(n^2) 或 O(nm) 了
    9. 对以上 O(n^2) 的 dp 可以具体问题具体分析来优化。
        例如 `CFE 170 D` 就是发现第一情况只有 O(m^2 + n) 的复杂度不影响   
        而二三情况实际上是区间加和, 要敏感地替换为差分
    10. 线性 dp 典: 求长为 m 的序列, 不平衡值(左括号数-右括号数)为 j 的方案数
        ```cpp
        ways[i + 1][j + 1] += ways[i][j]; // 作为匹配的括号
        ways[i + 1][j - 1] += ways[i][j]; // 作为不平衡的括号之一
        ```
        看到这里再看一下 `CFE 170 E` 吧, 很好的 dp

* 数据结构
    1. 可以借用 `std::map<int, int>` 将某些需要 `O(n)` 查找的问题优化到 `O(logn)`，    
        看起来很简单，但如 `P4447` 的这种用 `map` 存 `priority_queue<int>` 数组的 index 的做法还是很经验
    2. 数据结构的数据不一定就是题目中所给数据的组织关系，也可能存的是通过数据计算出的答案然后更新   
        例如 `P4447` 就是在 `priority_queue` 中存每个队的长度而不是队员实力值
    3. 同类元素的集合使用并查集, 尤其是对同类元素计数时   
        也可以用并查集管理线段, 当一个线段的所有点对题目计数要求来说是同类元素时   
        注意原理是合并时令编号较小的点做公共祖先得到的 leader 就是线段左端点 `L`   
        `L + d.size() - 1` 就是右端点.   
        而 AtCoder 的并查集板子是 size 较小的集合的祖先作为合并后的祖先, 所以要改一下 `merge` 

* 图论
    1. Dijkstra 最短路径可以在 `priority_queue<node>` 中的节点结构体加一个状态，并根据节点 `u` 的不同状态拓展更新 `v` 的边权 (`CF 974 Div3 E`)      
        此时要开多维的 `dis` 数组以记录不同状态下拓展出的当前最短路值，否则会丢失信息 (这种题类似分层图?)
    2. 路径最长边最小值用 Kruskal. 因为 Kruskal 的枚举边顺序，当两个点联通时就是两者最长边的最小值
        对于这个 MST 来说，首先计算过程决定了我们是不降得到这个 MST 各边权的
        其次就是注意 Kruskal 中并查集的特殊意义, 一个 fa[u] 代表了一个联通块的编号
    3. 题目有点顺序相关未必是拓扑排序, 如果是单纯的父子关系约束也可能是裸 bfs/dfs.   (`ABC 373 D`)
        补充: 或三色 bfs (`CFE 173 E`)
    4. 建图要把问题的关系描述完全, 比如题目给出单向边, 为了描述完整也可能加等效双向边(`ABC 373 D`)

* 扫描线
    1. 遇到线性事务相关，有进出事务的维护量的变化，需要用到扫描线
