* 思考方式
    1. 答案由什么构成?
        即观察题目性质。需要注意的是想到了一种答案构成/计算方法后不要局限，    
        考虑换个思路
    2. 构成的量多了试着"固定"某一个量(暴力或者二分 或者依据题意直接贪心计算出来)
    3. “计算答案包含的区间个数”更常见的做法是“计算每个区间对答案的贡献”    
        正难则反的另一种应用 (`CF 974 Div3 D`)
    4. 不要复杂度焦虑，多考虑几种暴力/模拟做法，再考虑正解(`P1904`)
    5. 当题目答案构成一眼看不出来时可以观察规律 究定义等（`P1904`）

* 性质/典/trick
    1. 同步加值不影响相对大小
    2. 找两个无公共部分的连续等长区间和的最大值可以枚举左区间计算最大值 `maxl`,
        同步更新 `maxl` + 右区间和的最大值
        ```cpp
        int maxk = -0x3f3f3f3f, ans = -0x3f3f3f3f;
        for(int i = k; i + k <= n; i++) {
            // [i - k + 1, i]   [i + 1, i + k]
            maxk = max(maxk, sum{i - k + 1, i});
            ans = max(ans, maxk + sum{i + 1, i + k});
        }
        ```
    3. 枚举两个无公共部分子区间可以枚举 `i` (前半段结尾后半段开始), 
        再分别枚举端点
        ```cpp
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= i; j++) cnt[a[i] ^ a[j - 1]]++;
            for(int j = i + 1; j <= n; j++) ans += cnt[a[j] ^ a[i + 1 - 1]];
        }
        ```
    4. 数字和字母挨在一块最好用 cin 读, 别先读入然后离线处理.
    5. 使用二进制表达集合的时候，标准化地使用 `1 << (i - 1)` 表示第 `i` 个元素在集合中
    6. 位运算的一些性质，如 `x | 1` 一定为 1，`x & 0` 一定为 0

* 贪心
    1. 贪心常和前缀和/后缀和联动
    2. 一定要看懂题，知道求的式子是什么。   
        贪心的核心是决策，不一定是推式子，搞清楚哪个是决策
    3. 然后可以考虑加入其他算法优化

* 差分
    1. `b[i] = a[i] - a[i - 1]`    
    在进行区间增减，求出某一个位置修改后的值时      
    `b[i]` 作为差分数组进行标记， `a[i]` 为 `b[i]` 的前缀和，代表位置 i 的值
    2. 具有区间加减法、求某一位修改后值特性的题目都要想着一点将题目转换为能够进行差分的形式。
    3. 可以从 0 计算 `b[i]` 达到只记录变化量, 而后在前缀和中具体计算值
    4. 将问题转化为区间增减、求单点值后， 可以通过从差分进行区间操作, 然后前缀和反构造出具体的单点值

* 前缀和
    1. 前缀和一定要考虑 `1~r`的情况,在考虑将 `l~r` 转换过去.
    2. 列式子拆括号化简可得出前缀和,因此要对式子中隐含的前缀和有概念
    3. 异或操作也可以前缀和
    4. 一定要注意前缀和化之后的数组不能再直接使用 a[p] 而是应当 `a[p] - a[p - 1]`
    5. 有连续区间, 答案/费用和区间和有关的都自然想一下前缀和

* 双指针
    1. 不要套滑动窗口板子, 滑动窗口的区间长度固定的
    2. 涉及到所求对象连续的就用一下双指针 

* 搜索
    1. 你只管搜索枚举, 剩下的交给 min/max 
    2. 注意搜索方向, 可能会有不能转弯的情况
    3. 千万注意数据范围能否搜索!!! (不仅要在意"否"也要在意"能")
    4. 搜索的复杂度是 解答树节点数 * 拓展节点的代价    
        但要注意解答树节点数不一定全部会拓展，更准确的计算方法是 枚举情况数 * 拓展节点代价
    5. 搜索的顺序十分值得注意，有时结合题目性质能剪枝一大部分(`P7073`)
    6. bfs 求01最短路的拓展：bfs求最小转弯次数（`P1649`）   
        此时为了保证三角不等式，必须每次拓展全部可以拓展的节点入队，然后再继续下一次迭代   
        对于本题也就是一直走到必须转弯的（障碍或边界）再停下（既转弯一次了），否则一直入队拓展节点

* 二分
    1. 常见的二分答案式的单调性是 对区间 $ [L,R] $ 上的函数 $ F(x) $, 存在 $ x_0 $ 使得...（略）
    2. 一种二分查找式的单调性：`ABC-380 E`，对于每个`/`来讲，左面的1少于右面的2则说明`/`偏左，否则偏右
    3. 大部分复杂度是 $ O(n\log n) $ 的，其中二分 $\log n$, check 可以是 n 的，不用担心。

* 递归
    1. 注意递归的终止条件, 部分递归虽然形式是一样的但终止条件略有不同, 如 `P1010` 这里不知道怎么说了, 感觉不如初高中脑子好使了
    2. 搜索能草掉很多递归范式. 别局限思路.
        将 n 拆分为 1, 2, 3, 4, .. , m 中几个数的和:
            (1) 深度优先搜索, 不降原则防止重复
            (2) 递归为两个情况: 将 n-m 分为不超过 m 的数的和, 将 n 分为不超过 m-1 的数的和
                推广到其他部分, m-1 也可以是 next(m) 等 (`recursion4.cpp`)

* 动态规划
    1. 注意 dp 数组一般为 i64, 以及 dp 数组开的是否够大(尤其对于字符串上 dp, 要注意 ASCII)
    2. 注意转移顺序, 以及是否越界
    3. 经典选或不选的模型, 因为两种决策中间的过程不一样, 所以要取 max
    4. 一般你觉得没有最优子结构性质的时候就考虑把你想的 dp 状态加一维
        巧妙一点的就是所谓接近答案要求但不完全是答案的中间状态     
        难绷一点就是状态压缩 dp 这种
    5. 动态规划处理的尺度是决策。只要决策不冲突或者能避免冲突，可以同时处理两条路径的决策( `P1004` 方格取数)
    6. 有时候 dp 初始化也需要注意，不能影响后续计算 dp 数组的值

* 数据结构
    1. 可以借用 `std::map<int, int>` 将某些需要 `O(n)` 查找的问题优化到 `O(logn)`，    
        看起来很简单，但如 `P4447` 的这种用 `map` 存 `priority_queue<int>` 数组的 index 的做法还是很经验
    2. 数据结构的数据不一定就是题目中所给数据的组织关系，也可能存的是通过数据计算出的答案然后更新   
        例如 `P4447` 就是在 `priority_queue` 中存每个队的长度而不是队员实力值

* 图论
    1. Dijkstra 最短路径可以在 `priority_queue<node>` 中的节点结构体加一个状态，并根据节点 `u` 的不同状态拓展更新 `v` 的边权 (`CF 974 Div3 E`)      
        此时要开多维的 `dis` 数组以记录不同状态下拓展出的当前最短路值，否则会丢失信息 (这种题类似分层图?)
