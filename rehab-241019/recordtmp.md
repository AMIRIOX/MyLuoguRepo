* 思考方式
    1. 答案由什么构成?
        即观察题目性质。需要注意的是想到了一种答案构成/计算方法后不要局限，    
        考虑换个思路
    2. 构成的量多了试着"固定"某一个量(暴力或者二分 或者依据题意直接贪心计算出来)
    3. “计算答案包含的区间个数”更常见的做法是“计算每个区间对答案的贡献”    
        正难则反的另一种应用 (`CF 974 Div3 D`)
    4. 不要复杂度焦虑，多考虑几种暴力/模拟做法，再考虑正解(`P1904`)
    5. 当题目答案构成一眼看不出来时可以观察规律 究定义等（`P1904`）
    6. 遇到问题时通过两方面思考
        * 一方面是答案如何构成?对于需要多次操作的问题, 最终答案会是什么样的?
            这一点需要细节,而不是大概的描述.例如对 `CF 991 Div3 D`, 
            不能只想"答案是包含相邻逆序对的递减序列", 还要想如何从初始状态构造出那样的答案.
        * 另一方面是在线动态做法, 除了总体策略上的离线贪心, 你应该更加去熟悉一下在线贪心
            即每次操作采取的特定决策. 通常第 i 次操作完成时, 前 i / 后 i 个都已经构造成了答案性质
            另外一次决策如果是"对某一对象采取某一操作"的形式, 不要拘泥于"对不同对象多次采取这次操作",
            也考虑一下这次操作对同一对象能不能延续操作
    7. 能枚举一个量就相当于可以少考虑一个条件, 因此看数据范围哪个能枚举也是比较重要的,
        正解很可能就是有一个量枚举然后剩下的量运用其他算法
    8. 有式子不一定是数学题, 尝试变个形, 对推式子积极一点, 而且别推一半想到了就做 (`CF 993 Div4 F`)
        继续往下推往往有更好的做法
    9. 哈希很有用. 不过 `std::map` 是红黑树, `std::unordered_map` 才是哈希表

* 性质/典/trick
    1. 同步加值不影响相对大小
    1. 如果每次操作都是+1 -1, 那么值的变化一定是连续的，[min, max] 之间的每个值都会出现
        对一个只存在-1 +1的数组，一个子数组的和是presum[r] - presum[l - 1], 枚举每个r，  
        减去的`presum[l - 1]`最小值就是和的最大值，减去最大值就是和的最小值
    1. 对 i 找 j 有出现 j 会再找到 i 导致计数重复时，可以直接除以二考虑。但也要考虑 i 找 i, i 再找回 i 的自身重复情况。
    2. 找两个无公共部分的连续等长区间和的最大值可以枚举左区间计算最大值 `maxl`,
        同步更新 `maxl` + 右区间和的最大值
        ```cpp
        int maxk = -0x3f3f3f3f, ans = -0x3f3f3f3f;
        for(int i = k; i + k <= n; i++) {
            // [i - k + 1, i]   [i + 1, i + k]
            maxk = max(maxk, sum{i - k + 1, i});
            ans = max(ans, maxk + sum{i + 1, i + k});
        }
        ```
    3. 枚举两个无公共部分子区间可以枚举 `i` (前半段结尾后半段开始), 
        再分别枚举端点
        ```cpp
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= i; j++) cnt[a[i] ^ a[j - 1]]++;
            for(int j = i + 1; j <= n; j++) ans += cnt[a[j] ^ a[i + 1 - 1]];
        }
        ```
    4. 数字和字母挨在一块最好用 cin 读, 别先读入然后离线处理.
    5. 使用二进制表达集合的时候，标准化地使用 `1 << (i - 1)` 表示第 `i` 个元素在集合中
    6. 位运算的一些性质，如 `x | 1` 一定为 1，`x & 0` 一定为 0

* 贪心
    1. 贪心常和前缀和/后缀和联动
    2. 一定要看懂题，知道求的式子是什么。   
        贪心的核心是决策，不一定是推式子，搞清楚哪个是决策
    3. 然后可以考虑加入其他算法优化

* 差分
    1. `b[i] = a[i] - a[i - 1]`    
    在进行区间增减，求出某一个位置修改后的值时      
    `b[i]` 作为差分数组进行标记， `a[i]` 为 `b[i]` 的前缀和，代表位置 i 的值
    2. 具有区间加减法、求某一位修改后值特性的题目都要想着一点将题目转换为能够进行差分的形式。
    3. 可以从 0 计算 `b[i]` 达到只记录变化量, 而后在前缀和中具体计算值
    4. 将问题转化为区间增减、求单点值后， 可以通过从差分进行区间操作, 然后前缀和反构造出具体的单点值

* 前缀和
    1. 前缀和一定要考虑 `1~r`的情况,在考虑将 `l~r` 转换过去.
    2. 列式子拆括号化简可得出前缀和,因此要对式子中隐含的前缀和有概念
    3. 异或操作也可以前缀和
    4. 一定要注意前缀和化之后的数组不能再直接使用 a[p] 而是应当 `a[p] - a[p - 1]`
    5. 有连续区间, 答案/费用和区间和有关的都自然想一下前缀和

* 双指针
    1. 不要套滑动窗口板子, 滑动窗口的区间长度固定的
    2. 涉及到所求对象连续的就用一下双指针 

* 搜索
    1. 你只管搜索枚举, 剩下的交给 min/max 
    2. 注意搜索方向, 可能会有不能转弯的情况
    3. 千万注意数据范围能否搜索!!! (不仅要在意"否"也要在意"能")
    4. 搜索的复杂度是 解答树节点数 * 拓展节点的代价    
        但要注意解答树节点数不一定全部会拓展，更准确的计算方法是 枚举情况数 * 拓展节点代价
    5. 搜索的顺序十分值得注意，有时结合题目性质能剪枝一大部分(`P7073`)
    6. bfs 求01最短路的拓展：bfs求最小转弯次数（`P1649`）   
        此时为了保证三角不等式，必须每次拓展全部可以拓展的节点入队，然后再继续下一次迭代   
        对于本题也就是一直走到必须转弯的（障碍或边界）再停下（既转弯一次了），否则一直入队拓展节点

* 二分
    1. 常见的二分答案式的单调性是 对区间 $ [L,R] $ 上的函数 $ F(x) $, 存在 $ x_0 $ 使得...（略）
    2. 一种二分查找式的单调性：`ABC-380 E`，对于每个`/`来讲，左面的1少于右面的2则说明`/`偏左，否则偏右
    3. 大部分复杂度是 $ O(n\log n) $ 的，其中二分 $\log n$, check 可以是 n 的，不用担心。
    4. 如果题目是求一个区间/区间长度, 可以分别看看左右端点 l r 有没有单调性. 可以看看 `CF 993 Div4 E`
    5. `upper_bound(.., vmax) - lowerbound(.., vmin)` 求 `..` 中值在 `[vmin, vmax]` 之间的个数。
        当然， `..` 要有序。
    6. 要有大局意识，对 i 找 j 有重复，发现 j 找 i 也会找一边，所以不去重，最后除以二即可 `(CF 995 Div3)`
        但要注意除了 i 找 j == j 找 i 这种二倍重复之外，还有可能出现 i 找到 i, i 再找到 i 的情况

* 递归
    1. 注意递归的终止条件, 部分递归虽然形式是一样的但终止条件略有不同, 如 `P1010` 这里不知道怎么说了, 感觉不如初高中脑子好使了
    2. 搜索能草掉很多递归范式. 别局限思路.
        将 n 拆分为 1, 2, 3, 4, .. , m 中几个数的和:
            (1) 深度优先搜索, 不降原则防止重复
            (2) 递归为两个情况: 将 n-m 分为不超过 m 的数的和, 将 n 分为不超过 m-1 的数的和
                推广到其他部分, m-1 也可以是 next(m) 等 (`recursion4.cpp`)

* 动态规划
    1. 注意 dp 数组一般为 i64, 以及 dp 数组开的是否够大(尤其对于字符串上 dp, 要注意 ASCII)
    2. 注意转移顺序, 以及是否越界
    3. 经典选或不选的模型, 因为两种决策中间的过程不一样, 所以要取 max
    4. 一般你觉得没有最优子结构性质的时候就考虑把你想的 dp 状态加一维
        巧妙一点的就是所谓接近答案要求但不完全是答案的中间状态     
        难绷一点就是状态压缩 dp 这种
    5. 动态规划处理的尺度是决策。只要决策不冲突或者能避免冲突，可以同时处理两条路径的决策( `P1004` 方格取数)
    6. 有时候 dp 初始化也需要注意，不能影响后续计算 dp 数组的值
    7. 我懒得写了也说不出来什么了, 我就纳闷怎么有人特么式子都写对了然后计算边界和初始值写不对的, 自己看 `CF 991 Div3 E`吧.
        算了还是写一下吧.
        * 遇到字符串 dp, 下标不统一的话按 dp 状态的实际意义来, 再在str[i - 1]中映射
        * min 决策的 dp 每个状态初始值都填一下 inf (或者结合实际问题下的最大答案)
        * (存疑) 一般很多 dp 初始化直接 `dp[0][0] = ` 就行了? 再多些题具体分析吧.
        * 状态转移不仅要考虑决策(即 min 实现的部分), 也要考虑从每次决策是怎么**从之前的状态**转移过来的
            (即 min(A, B) 中 A, B 的计算往往和先前的 dp 状态有关系)
        * 关于计算边界问题: 遇到二维状态中有一维需要依赖-1的, 也可以用+1往后算代替
            如果遇到两个维度的边界不同就都枚举到最大边界, 然后加个判断约束一下

* 数据结构
    1. 可以借用 `std::map<int, int>` 将某些需要 `O(n)` 查找的问题优化到 `O(logn)`，    
        看起来很简单，但如 `P4447` 的这种用 `map` 存 `priority_queue<int>` 数组的 index 的做法还是很经验
    2. 数据结构的数据不一定就是题目中所给数据的组织关系，也可能存的是通过数据计算出的答案然后更新   
        例如 `P4447` 就是在 `priority_queue` 中存每个队的长度而不是队员实力值

* 图论
    1. Dijkstra 最短路径可以在 `priority_queue<node>` 中的节点结构体加一个状态，并根据节点 `u` 的不同状态拓展更新 `v` 的边权 (`CF 974 Div3 E`)      
        此时要开多维的 `dis` 数组以记录不同状态下拓展出的当前最短路值，否则会丢失信息 (这种题类似分层图?)
    2. 路径最长边最小值用 Kruskal. 因为 Kruskal 的枚举边顺序，当两个点联通时就是两者最长边的最小值
        对于这个 MST 来说，首先计算过程决定了我们是不降得到这个 MST 各边权的
        其次就是注意 Kruskal 中并查集的特殊意义, 一个 fa[u] 代表了一个联通块的编号
