/*
士兵的集结任务

在遥远的勇者大陆上，一场激烈的战争刚刚结束，士兵们分散在各地，等待重新归队的命令。大陆的地图上标注着各种地形和关键的集结点，士兵们需要尽快赶往这些地方完成集结，重新组织军队。然而，地形复杂士兵众多，总指挥官感到一筹莫展。

地图上有以下几种元素
  1.空地：用数字 0 表示，士兵可以自由通行。
  2.障碍物：用数字 1 表示，士兵无法通过。
  3.集结点：用数字 2 表示，士兵需要前往的目的地。
  4.士兵：用 ≥3 表示，表示士兵，同时也代表士兵人数。其他士兵可以自由通行。

这时，一位足智多谋的军师津津站了出来，津津提出了一套完美的策略：
每组士兵前往距离最近的集结点，如果一组士兵有多个距离相等的集结点时，请确保其中一处集结点的士兵达到最大化。

总指挥官的任务是根据津津的策略，合理的调动士兵，每组士兵每天可以上下左右选择一个方向移动 1 个单位，请计算当行军指定天数后，士兵数量最多的集结点有多少士兵。

输入：
一个二维数组，表示地图，数组各维度大小为 1 ≤ n ≤ 50 。
一个整数，1 ≤ n ≤ 30 ，表示行军天数。

输出：
一个整数，士兵数量最多的集结点有多少士兵。
*/
#include <bits/stdc++.h>
using namespace std;

int dx[] = {-1, 0, 1, 0};
int dy[] = {0, -1, 0, 1};
int n, d;

#define mp(i, j) (a[(i - 1) * n + (j - 1)])
signed main() {
    cin.tie(0) -> sync_with_stdio(false);
    vector<int> a;
    int t;
    while(cin >> t) {
        a.push_back(t);
    }
    d = *(a.end() - 1);
    cout << d << endl;
    n = (int) sqrt(a.size() - 1);
    
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            if(mp(i, j) >= 3) {

            }
        }
    }
    return 0;
}
