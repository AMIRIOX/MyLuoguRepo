#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 210;
// 设f(x)(k)(p),p=n-x;
// f(x')(k')(p')=
// f(x'-p-1)(k'-1)(p'+1)+
// f(x'-p'-2)(p'+2)+...+f(ceil(x'/2))(k'-1)(符合条件的p)

// sb. f[i][j]=f[i-t][j-1];
// t写在外部避免重复。
/*3 1和1 3为什么不会重复？
4分2份时先计算到[3][1]再[1][3]（因为[i-t][t]的t是从小到大枚举的）
而先计算的[3][1]并不会被计算上，因为这个时候[3][1]还没被计算，还只是0
为什么这时候[3][1]没被计算？[3][1]的计算需要[0][3]（t不可能是0所以没有[3][0])，
而[0][3]的计算是在t=3的循环中，远远远于[3][t=1]的循环
推广到整体:
x y和y x (x<y)为什么不会重复？
x+y分2份时先计算到[x][y]再[y][x]（因为[i-t][t]的t是从小到大枚举的）
而先计算的[y][x]并不会被计算上，因为这个时候[y][1]还没被计算，还只是0
为什么这时候[y][1]没被计算？[y][1]的计算需要[0][y]（t不可能是0所以没有[y][0])，
而[0][y]的计算是在t=y的循环中，远远远于[3][t=1]的循环(x>=1, y>x, y>1)
尝试简化：
简单地说，并不是不计算[大][小]只计算[小][大]，
而是通过控制t让[大][小]比[小][大]先计算，
“而[0][大]的计算是在t=大的循环中”，只有[_][被分成大了]，[0][大]才可能被计算
[大][小]显然是不满足[_][大]已经被计算过了的
再简化:
计算到[b][t=a]时t=b的循环还未进行，分为[0][b]两段无效
语言描述：
前半段从大到小枚举，后半段从小到大枚举；
后半段没到枚举到大时前半段无效
*/

// f[n][k]=f[n-1][k-1] | f[n-i][i];
//  (1+a)(1+b)(1+c)
int f[maxn][maxn];
int main() {
    int n, k;
    cin >> n >> k;
    f[0][0]=1;
    // for (int g = 2; g <= k; g++) {
    //     for (int x = 1; x <= n; x++) {
    //         int p1 = n - x;
    //         printf("calc f[%d][%d]=", x, g);
    //         for (int i = x - p1 - 1; i >= ceil(x / 2); i--) {
    //             printf("f[%d][%d]", i, g-1);
    //             f[x][g] += f[i][g-1];
    //         }
    //         puts("");
    //     }
    // }
    for (int t = 1; t <= n; t++) {
        for (int i = t; i <= n; i++) {
            for (int j = 1; j <= k; j++)
                f[i][j] += f[i - t][j - 1];
        }
    }
    cout << f[n][k] << endl;
    return 0;
}
